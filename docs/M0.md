# M0 — Repo Reality Snapshot

Last updated: 2026-01-23

This file records what is **implemented and integrated in this repository today**, the **decisions already encoded in code**, and the **constraints those decisions impose** on future work. Treat it as a “do not accidentally break this” reference.

## What works end-to-end (integrated)
- Web app loads a Google map, fetches nodes for the current viewport, renders markers, and can open node detail routes.
- Anonymous session is established automatically (device-based), and the browser includes the session cookie on API calls.
- On-site check-in is implemented (challenge → server geofence verify → short-lived one-time token).
- Capture creation + upload is implemented:
  - capture record creation requires a valid, unused check-in token
  - image upload promotes the capture into the verification queue
  - uploads survive offline + reload via a persisted upload intent queue in the web app
- Admin-driven verification is implemented (admin token):
  - transition pending captures to verified/rejected/hidden
  - verification creates user notifications and updates curator rank
  - optional auto-publish on verification when the user requested publish and required rights/attribution fields are present
- Public viewing + reporting is implemented:
  - verified + published captures are visible on node detail
  - users can report captures; admins can resolve reports and optionally hide/takedown captures
- Tips are implemented (Solana devnet) behind a web feature flag:
  - server-issued tip intents + memo linkage
  - receipt verification via Solana RPC and DB-backed node tip totals
  - seeded recipient pubkeys are demo placeholders (addresses only; no ownership/claim flow)

## Integrations (current stack)

### Web (`apps/web`)
- Vite + React + TypeScript
- React Router (`/map`, `/nodes/:nodeId`, `/capture/:captureId?`)
- Google Maps JS via `@react-google-maps/api` (map + directions rendering)
- Browser Geolocation API for check-in and directions origin
- API client uses `fetch` with `credentials: "include"` (session cookie)
- IndexedDB-backed upload queue (retry/backoff; survives offline + reload)
- Solana Wallet Adapter (tips UX, feature-flagged)

### API (`apps/api`)
- FastAPI + Pydantic settings (`.env` at repo root)
- Postgres + PostGIS (via Docker) with:
  - SQLAlchemy 2.x async + `asyncpg`
  - GeoAlchemy2 for geometry types/queries
  - Alembic migrations (initial schema installs PostGIS extension)
- Media upload: `python-multipart` + development-only local storage under `MEDIA_DIR`, served at `/media/*`
- Observability:
  - `X-Request-ID` response header (echo/auto-generate) via middleware
  - Prometheus metrics at `GET /metrics`
  - optional OpenTelemetry tracing
- Testing: `pytest` + `pytest-asyncio` + `httpx` (ASGI transport) + real PostGIS
- Linting: Ruff (configured in `apps/api/pyproject.toml`)

### Infra (`infra`)
- `infra/docker-compose.yml` runs `kartoza/postgis:16-3.4` for local development.
- `infra/docker-compose.yml` includes a tip receipt reconciler service and seeds nodes + artists on first boot.

### Data (`data/seed`)
- `data/seed/nodes.json` starter dataset + `apps/api/scripts/seed_nodes.py` to upsert nodes.
- `data/seed/artists.json` starter dataset + `apps/api/scripts/seed_artists.py` to upsert artists and attach nodes’ default tip recipient.
- Seed licensing notes live in `data/seed/README.md` (includes Google Places ToS constraints).

### Domain package (`packages/domain`)
- Canonical JSON schemas for shared vocabulary:
  - `packages/domain/schemas/node_public.json`
  - `packages/domain/schemas/capture_state.json`
  - `packages/domain/schemas/error.json`
- Codegen is not wired yet; these schemas are the intended cross-language source of truth.

## API surface area (current)
- `GET /health`
- `POST /v1/sessions/anonymous` (device-based session cookie)
- `GET /v1/me` (current user + rank)
- `GET /v1/me/notifications` and `POST /v1/me/notifications/{notification_id}/read`
- `GET /v1/nodes?bbox=minLng,minLat,maxLng,maxLat` (viewport discovery; rank-gated)
- `GET /v1/nodes/{node_id}` (rank-gated)
- `GET /v1/nodes/{node_id}/captures?state=verified` (detail page support; non-verified states require admin token)
- `POST /v1/nodes/{node_id}/checkins/challenge` (one-time challenge)
- `POST /v1/nodes/{node_id}/checkins` (geofence verify; issues check-in token)
- `POST /v1/captures` (requires valid, unused check-in token; creates `draft` capture pending upload)
- `GET /v1/captures/{capture_id}` (owner-only)
- `PATCH /v1/captures/{capture_id}` (owner-only; attribution/rights updates)
- `POST /v1/captures/{capture_id}/image` (owner-only; uploads capture image and promotes to `pending_verification`)
- `POST /v1/captures/{capture_id}/publish` (owner-only; requires verified state + rights/attribution fields)
- `POST /v1/captures/{capture_id}/reports` (create a content report)
- Admin endpoints (require `X-Admin-Token`):
  - `GET /v1/admin/captures/pending`
  - `POST /v1/admin/captures/{capture_id}/transition`
  - `GET /v1/admin/reports` and `POST /v1/admin/reports/{report_id}/resolve`
  - `GET /v1/admin/abuse-events`
- Tips:
  - `POST /v1/tips/intents` and `POST /v1/tips/confirm`
  - `GET /v1/nodes/{node_id}/tips`
- Observability:
  - `GET /metrics`

Error shape is standardized:
`{ "error": { "code": string, "message": string, "details": object } }`.

## Database schema (current)
Core tables (current schema):
- `users`: server-side identity (no login flow yet)
- `devices`: stable mapping `device_id -> user_id`
- `sessions`: hashed opaque tokens + expiry (cookie value is never stored in DB)
- `nodes`: discovery records with `POINT` geometry (`srid=4326`), `radius_m`, and `min_rank`
- `artists`: tip recipient identities for the demo (no claim flow yet)
- `nodes.default_artist_id`: default tip recipient per node
- `checkin_challenges`: short-lived one-time challenges (replay protection)
- `checkin_tokens`: short-lived one-time tokens used to authorize capture creation
- `captures`: capture state + visibility, rights/attribution fields, and optional `image_path`/`image_mime`
- `capture_events`: capture audit log (state transitions, publish events)
- `user_notifications`: per-user notification feed (e.g. verification/publish outcomes)
- `content_reports`: user reports + admin resolution
- `abuse_events`: recorded rate-limit and abuse signals (outside geofence, invalid challenge, etc.)
- `rank_events`: append-only rank event log with deterministic ids (idempotent inserts)
- `curator_rank_daily`: per-user per-day rank aggregates (materialized)
- `curator_rank_cache`: per-user current rank snapshot (materialized)
- `tip_intents`: server-issued tip “payment plans” (memo-linked)
- `tip_receipts`: verified on-chain receipts + later reconciliation status

## Decisions already made (and what they constrain)
- **Google Maps Platform is the map substrate**: web UI assumes Google Maps JS, and seed data must respect Places/Maps ToS constraints.
- **Postgres + PostGIS is the geo authority**: API performs bbox queries and geofence checks server-side; do not move these decisions client-side.
- **Geofence model is “point + radius” for M1**: check-in uses `ST_DWithin` against the node center/radius. M1 requires `radius_m >= 25` and polygon support is explicitly a later, additive change.
- **Anonymous sessions first**: identity is device-based (`device_id`) with an HttpOnly cookie session; future “real auth” should upgrade/attach to the same `user`.
- **Opaque tokens stored as hashes**: session/check-in tokens are generated random values; only SHA-256 hashes (with `TOKEN_HASH_SECRET`) are persisted.
- **API versioning starts at `/v1`**: new endpoints go under `/v1`; avoid breaking existing response shapes (especially `NodePublic`).
- **Development media is local**: uploads go to `MEDIA_DIR` and are served via `/media`. Production storage should sit behind a storage interface and use signed URLs.
- **Capture public visibility is enforced server-side**: “public” requires verified state plus required rights/attribution fields; hiding/takedown removes public visibility.
- **Rank is event-derived and materialized**: verified captures append deterministic rank events and refresh daily/cache aggregates.
- **Tips are receipt-verified (not scanned)**: the API verifies a submitted tx against memo + transfer rules; totals are DB-backed and reconciliation upgrades finality over time.
- **Domain vocabulary is intended to be shared**: JSON schemas in `packages/domain/schemas/` should stay aligned with API response models and web types.

## Going forward (rules of thumb)
- Treat the API as the authority: client location, timestamps, and EXIF are always untrusted evidence.
- Keep discovery payloads small and viewport-based (bbox/radius queries), and keep gating on the read path (not only UI hiding).
- If `NodePublic` changes, update both API schema (`apps/api/src/groundedart_api/api/schemas.py`) and the domain schema (`packages/domain/schemas/node_public.json`), and adjust web types accordingly.
- Anything that changes token/cookie semantics (CORS, `SameSite`, `secure`) must be evaluated for local dev ergonomics and production security.

## Not integrated yet (explicitly)
- Real user authentication (email/OAuth), account recovery, device migration
- Async verification/scoring pipeline (queues/workers), perceptual hashing, richer moderation tooling
- Object storage (S3/R2/etc) and signed media URLs
- Production-grade media access control (dev `/media/*` is unauthenticated)
- Artworks and richer artist modeling (beyond demo `artists` and `nodes.default_artist_id`)
- Rights/consent enforcement beyond the current “required fields before public” rule set

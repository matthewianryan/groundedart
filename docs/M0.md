# M0 — Repo Reality Snapshot

This file records what is **implemented and integrated in this repository today**, the **decisions already encoded in code**, and the **constraints those decisions impose** on future work. Treat it as a “do not accidentally break this” reference.

## What works end-to-end (scaffold)
- Web app loads a Google map, fetches nodes for the current viewport, renders markers, and can open a basic node detail route.
- Anonymous session is established automatically (device-based), and the browser includes the session cookie on API calls.
- On-site check-in is implemented (challenge → geofence verify → short-lived token).
- A capture record can be created from a valid check-in token, and an image can be uploaded and served back via the API’s `/media` route (development storage).

## Integrations (current stack)

### Web (`apps/web`)
- Vite + React + TypeScript
- React Router (`/map`, `/nodes/:nodeId`)
- Google Maps JS via `@react-google-maps/api` (map + directions rendering)
- Browser Geolocation API for check-in and directions origin
- API client uses `fetch` with `credentials: "include"` (session cookie)

### API (`apps/api`)
- FastAPI + Pydantic settings (`.env` at repo root)
- Postgres + PostGIS (via Docker) with:
  - SQLAlchemy 2.x async + `asyncpg`
  - GeoAlchemy2 for geometry types/queries
  - Alembic migrations (initial schema installs PostGIS extension)
- Media upload: `python-multipart` + development-only local storage under `MEDIA_DIR`, served at `/media/*`
- Testing: `pytest` + `pytest-asyncio` + `httpx` (ASGI transport) + real PostGIS
- Linting: Ruff (configured in `apps/api/pyproject.toml`)

### Infra (`infra`)
- `infra/docker-compose.yml` runs `kartoza/postgis:16-3.4` for local development.

### Data (`data/seed`)
- `data/seed/nodes.json` starter dataset + `apps/api/scripts/seed_nodes.py` to upsert nodes.
- Seed licensing notes live in `data/seed/README.md` (includes Google Places ToS constraints).

### Domain package (`packages/domain`)
- Canonical JSON schemas for shared vocabulary:
  - `packages/domain/schemas/node_public.json`
  - `packages/domain/schemas/capture_state.json`
  - `packages/domain/schemas/error.json`
- Codegen is not wired yet; these schemas are the intended cross-language source of truth.

## API surface area (current)
- `GET /health`
- `POST /v1/sessions/anonymous` (device-based session cookie)
- `GET /v1/me` (current user + rank)
- `GET /v1/nodes?bbox=minLng,minLat,maxLng,maxLat` (viewport discovery; rank-gated)
- `GET /v1/nodes/{node_id}` (rank-gated)
- `GET /v1/nodes/{node_id}/captures?state=verified` (detail page support)
- `POST /v1/nodes/{node_id}/checkins/challenge` (one-time challenge)
- `POST /v1/nodes/{node_id}/checkins` (geofence verify; issues check-in token)
- `POST /v1/captures` (requires valid, unused check-in token; creates `draft` capture pending upload)
- `POST /v1/captures/{capture_id}/image` (uploads capture image; development local storage)

Error shape is standardized:
`{ "error": { "code": string, "message": string, "details": object } }`.

## Database schema (current)
Core tables (current schema):
- `users`: server-side identity (no login flow yet)
- `devices`: stable mapping `device_id -> user_id`
- `sessions`: hashed opaque tokens + expiry (cookie value is never stored in DB)
- `nodes`: discovery records with `POINT` geometry (`srid=4326`), `radius_m`, and `min_rank`
- `checkin_challenges`: short-lived one-time challenges (replay protection)
- `checkin_tokens`: short-lived one-time tokens used to authorize capture creation
- `captures`: minimal capture record, attribution fields, and optional `image_path`/`image_mime`
- `rank_events`: append-only rank event log
- `curator_rank_daily`: per-user per-day rank aggregates (materialized)
- `curator_rank_cache`: per-user current rank snapshot (materialized)

## Decisions already made (and what they constrain)
- **Google Maps Platform is the map substrate**: web UI assumes Google Maps JS, and seed data must respect Places/Maps ToS constraints.
- **Postgres + PostGIS is the geo authority**: API performs bbox queries and geofence checks server-side; do not move these decisions client-side.
- **Geofence model is “point + radius” for M1**: check-in uses `ST_DWithin` against the node center/radius. M1 requires `radius_m >= 25` and polygon support is explicitly a later, additive change.
- **Anonymous sessions first**: identity is device-based (`device_id`) with an HttpOnly cookie session; future “real auth” should upgrade/attach to the same `user`.
- **Opaque tokens stored as hashes**: session/check-in tokens are generated random values; only SHA-256 hashes (with `TOKEN_HASH_SECRET`) are persisted.
- **API versioning starts at `/v1`**: new endpoints go under `/v1`; avoid breaking existing response shapes (especially `NodePublic`).
- **Development media is local**: uploads go to `MEDIA_DIR` and are served via `/media`. Production storage should sit behind a storage interface and use signed URLs.
- **Domain vocabulary is intended to be shared**: JSON schemas in `packages/domain/schemas/` should stay aligned with API response models and web types.

## Going forward (rules of thumb)
- Treat the API as the authority: client location, timestamps, and EXIF are always untrusted evidence.
- Keep discovery payloads small and viewport-based (bbox/radius queries), and keep gating on the read path (not only UI hiding).
- If `NodePublic` changes, update both API schema (`apps/api/src/groundedart_api/api/schemas.py`) and the domain schema (`packages/domain/schemas/node_public.json`), and adjust web types accordingly.
- Anything that changes token/cookie semantics (CORS, `SameSite`, `secure`) must be evaluated for local dev ergonomics and production security.

## Not integrated yet (explicitly)
- Real user authentication (email/OAuth), account recovery, device migration
- Async verification/scoring pipeline (queues/workers), perceptual hashing, moderation tooling
- Object storage (S3/R2/etc) and signed media URLs
- Deterministic idempotency keys for future rank events (today: unique `(event_type, capture_id)` for `capture_verified`)
- Capture visibility policy and rights/consent enforcement beyond “fields exist”

# M1 — On-site check-in (implementation record)

This file documents the **implemented** M1 behavior and the **choices already encoded in code**. It is meant to be a concrete, “do not accidentally drift this” reference for Milestone 1 in `docs/ROADMAP.md`.

## Scope (per ROADMAP M1)
- A user can only begin a capture flow when physically inside a node’s geofence.
- Server-side check-in flow uses challenge/nonce + expiring token + replay protection.
- UX for “not inside the zone” accounts for GPS accuracy and intermittent connectivity.
- API provides stable reason codes for check-in failure.

## Authoritative geofence model (server)
- **Model**: node geofence is **point + radius** in meters (no polygons in M1).
- **Authority**: inside/outside is decided by the API (PostGIS), not by the client.
- **Minimum radius**: `radius_m >= 25` enforced in DB and schemas.
- **Spatial decision**: `ST_DWithin(Geography(node_point), Geography(user_point), radius_m)` with meters.
- **Distance feedback**: on failure, server computes `ST_Distance` (meters) for UX when available.

References:
- `apps/api/src/groundedart_api/db/models.py` (Node geometry, `radius_m` constraint)
- `apps/api/src/groundedart_api/api/routers/nodes.py` (ST_DWithin + ST_Distance)
- `apps/api/src/groundedart_api/db/migrations/versions/20260123_0002_nodes_radius_min_25.py`
- `packages/domain/schemas/node_public.json`

## Check-in API contracts (shared domain)
- `POST /v1/nodes/{node_id}/checkins/challenge` returns `{ challenge_id, expires_at }`.
- `POST /v1/nodes/{node_id}/checkins` accepts `{ challenge_id, lat, lng, accuracy_m }`
  and returns `{ checkin_token, expires_at }`.
- Error envelope is `{ "error": { "code", "message", "details" } }`.
- Check-in error codes are defined as a strict enum.

References:
- `packages/domain/schemas/checkin_challenge_response.json`
- `packages/domain/schemas/checkin_request.json`
- `packages/domain/schemas/checkin_response.json`
- `packages/domain/schemas/checkin_error_code.json`
- `apps/api/src/groundedart_api/api/schemas.py`
- `apps/web/src/features/checkin/api.ts`
- `apps/web/src/api/http.ts`

## Server-side check-in flow (challenge → verify → token)

### Challenge issuance
- **Endpoint**: `POST /v1/nodes/{node_id}/checkins/challenge`.
- **State**: stored in `checkin_challenges` with `expires_at` and `used_at`.
- **Binding**: challenge is tied to `(user_id, node_id)`.
- **TTL**: `CHECKIN_CHALLENGE_TTL_SECONDS` (default 120s).

### Verification
- **Required inputs**: `challenge_id`, `lat`, `lng`, `accuracy_m`.
- **Accuracy gate**: reject if `accuracy_m > MAX_LOCATION_ACCURACY_M` (default 50m).
- **Geofence gate**: reject if outside radius (uses PostGIS geography).
- **Failure codes**:
  - `node_not_found` (404)
  - `invalid_challenge` (400)
  - `challenge_used` (400)
  - `challenge_expired` (400)
  - `location_accuracy_too_low` (400, details include `accuracy_m`, `max_allowed_m`)
  - `outside_geofence` (403, details include `radius_m`, optional `distance_m`)

### Token issuance
- **Token**: opaque random value generated server-side; only a hash is stored.
- **Storage**: `checkin_tokens` with `expires_at` and `used_at`.
- **Binding**: token is tied to `(user_id, node_id)`.
- **TTL**: `CHECKIN_TOKEN_TTL_SECONDS` (default 600s).
- **Replay protection**: challenges are single-use (`used_at`), tokens are single-use (`used_at`).

References:
- `apps/api/src/groundedart_api/api/routers/nodes.py`
- `apps/api/src/groundedart_api/db/models.py`
- `apps/api/src/groundedart_api/auth/tokens.py`
- `apps/api/src/groundedart_api/settings.py`
- `.env.example`
- `apps/api/src/groundedart_api/db/migrations/versions/20260123_0003_checkin_indexes.py`

## Capture gating (token required)
- **Endpoint**: `POST /v1/captures` requires `checkin_token` and `node_id`.
- **Enforcement**:
  - token must exist, be unused, unexpired, and bound to `(user_id, node_id)`.
  - failures return `invalid_checkin_token` (400) or `checkin_token_expired` (400).
- **One-time use**: token is marked `used_at` when capture is created.
- **Capture state**: created as `pending_verification` with `state_reason="geo_passed"`.

References:
- `apps/api/src/groundedart_api/api/routers/captures.py`
- `packages/domain/schemas/create_capture_request.json`
- `packages/domain/schemas/create_capture_response.json`

## Web UX (check-in flow)
- **State machine**: `idle → requesting_location → challenging → verifying → success/failure`.
- **Online-only**: check-in is blocked when offline; user must reconnect to retry.
- **Location acquisition**: browser geolocation with `enableHighAccuracy` and 10s timeout.
- **Failure messaging**:
  - GPS errors (permission denied, unavailable, timeout) mapped to specific copy.
  - API error codes map to UX states (accuracy too low, outside geofence, expired challenge).
- **Guidance**: shows `accuracy_m`, `distance_m`, and `radius_m` when provided; includes “Retry” and “Get directions”.
- **Capture CTA gating**: “Create capture” is disabled unless a check-in token is present.

References:
- `apps/web/src/routes/MapRoute.tsx`
- `apps/web/src/features/checkin/api.ts`

## Persistence and indexing choices
- `checkin_challenges` and `checkin_tokens` tables store TTL and used timestamps.
- Hash-only storage for check-in tokens (`TOKEN_HASH_SECRET` in env config).
- Indexes on `(user_id, node_id, expires_at)` for both challenges and tokens for lookup/cleanup.

References:
- `apps/api/src/groundedart_api/db/models.py`
- `apps/api/src/groundedart_api/db/migrations/versions/20260123_0003_checkin_indexes.py`
- `.env.example`

## Tests covering M1
- **Check-in flow**: invalid/expired/used challenge, accuracy too low, outside geofence, successful token issuance.
- **Capture gating**: invalid token, expired token, reused token, wrong node binding.

References:
- `apps/api/tests/test_checkin.py`
- `apps/api/tests/test_capture_tokens.py`

## Potential intent drifts / open items (optional)
- `docs/TASKS.md` still marks **M1-05** as incomplete, but token gating for `POST /v1/captures` is implemented and tested; update task status to avoid roadmap drift.
- `invalid_challenge` no longer returns identifiers in the payload; the identifiers are logged server-side only.
- Capture error responses now have shared schemas (`packages/domain/schemas/capture_error_code.json`, `packages/domain/schemas/capture_error_response.json`) to avoid client/server drift.

# Milestone 4 — Rank + gating (implementation review)

This document summarizes the current Milestone 4 implementation in this repo (per `docs/ROADMAP.md`), focused on **derived rank from verified actions**, an **auditable rank event log**, **API-enforced gating** on read + write paths, and a **minimal “why” UX** powered by `/v1/me`.

The canonical policy for this milestone lives in `docs/RANK_GATING.md`; this file describes what is actually implemented in code today.

## Rank policy (v1_points)
- Rank is computed from **verified captures only** (no rank from check-ins, uploads, or drafts).
- Rank is derived from an append-only event log and recomputed from current still-verified captures (rank can go down after moderation).
- Caps are implemented (and mirrored in the API breakdown):
  - **Per node per UTC day**: max 1 point counted.
  - **Per user per UTC day**: max 3 points counted.

References:
- Policy: `docs/RANK_GATING.md`
- Projection: `apps/api/src/groundedart_api/domain/rank_projection.py`

## Rank event log (DB) + idempotent writes
- Storage model: `rank_events` via `CuratorRankEvent` in `apps/api/src/groundedart_api/db/models.py`.
- Migration: `apps/api/src/groundedart_api/db/migrations/versions/20260123_0007_rank_events.py`.
- Idempotency: unique constraint on `(event_type, capture_id)` prevents duplicate events for the same trigger.
- Domain helper: `append_rank_event(...)` uses `INSERT .. ON CONFLICT DO NOTHING` and returns the inserted-or-existing event deterministically.

References:
- Domain write helpers: `apps/api/src/groundedart_api/domain/rank_events.py`
- DB model: `apps/api/src/groundedart_api/db/models.py`

## Rank event emission (verification → rank)
- Emission is centralized at the authoritative verification transition:
  - When a capture transitions to `verified`, a `capture_verified` event with `delta=1` is appended (linked to `capture_id` and `node_id`).
- This keeps “verified actions only” enforceable in one place and ensures rank is auditable via the ledger.

References:
- Transition + emission point: `apps/api/src/groundedart_api/domain/capture_moderation.py`
- Event type constant: `apps/api/src/groundedart_api/domain/rank_events.py`

## Rank projection (derive rank from events)
- `compute_rank_projection(...)` builds rank as a deterministic function of persisted rank events:
  - It loads `capture_verified` events for the user and joins against `captures` to ensure only captures still in `verified` state contribute.
  - It applies the per-node/day and per-day caps and returns a breakdown suitable for UX and debugging.
  - It computes `next_unlock` by comparing current rank to the tier table in `domain/gating.py`.
- `get_rank_for_user(...)` is the current “rank lookup” used by gating and endpoints.

References:
- Projection: `apps/api/src/groundedart_api/domain/rank_projection.py`
- Tier table used for `next_unlock`: `apps/api/src/groundedart_api/domain/gating.py`

## Gating rules and enforcement (API-level)

### Centralized gating helpers
- Tier table (`RANK_TIERS`) defines rank-dependent throughput limits.
- Gating functions raise `AppError` with stable codes and structured details:
  - Rank gating: `rank_locked` (409) with `current_rank`, `required_rank`, and tier metadata.
  - Rate limiting: `checkin_challenge_rate_limited` (429) and `capture_rate_limited` (429) with tier + window details.
- Discovery “locked node” behavior omits locked nodes from list endpoints and returns explicit `NodeLocked` payloads on direct access (200).

References:
- Central gating module: `apps/api/src/groundedart_api/domain/gating.py`
- Error code enums: `packages/domain/schemas/node_error_code.json`, `packages/domain/schemas/checkin_error_code.json`, `packages/domain/schemas/capture_error_code.json`

### Read-path gating (discovery + node content)
- `GET /v1/nodes` is server-filtered: `nodes.min_rank <= user.rank` (anonymous users are rank 0).
- `GET /v1/nodes/{id}` returns `200` with `NodeLocked` when rank is insufficient.
- `GET /v1/nodes/{id}/captures` returns `NodeLocked` with an empty `captures` list when rank is insufficient.

References:
- Node routers: `apps/api/src/groundedart_api/api/routers/nodes.py`

### Write-path gating (check-in + capture)
- Check-in challenge issuance is tiered per user/node/window:
  - `POST /v1/nodes/{id}/checkins/challenge` uses `assert_can_checkin_challenge(...)`.
- Check-in issuance is rank-gated and also enforces the tiered capture throughput limit:
  - `POST /v1/nodes/{id}/checkins` uses `assert_can_access_node(...)` and `assert_can_checkin(...)`.
- Capture creation is rank-gated and tiered per user/node/window:
  - `POST /v1/captures` uses `assert_can_create_capture(...)`.

References:
- Check-in router: `apps/api/src/groundedart_api/api/routers/nodes.py`
- Capture router: `apps/api/src/groundedart_api/api/routers/captures.py`

## “Why” UX and `/v1/me` contract
- `GET /v1/me` returns:
  - `rank`, `rank_version`
  - `rank_breakdown` (including caps applied)
  - `next_unlock` (threshold + summary + unlock strings)
- Web UX uses this to explain progress and gating outcomes:
  - Map shows current rank, next unlock, and cap notes.
  - Capture flow renders targeted “Why can’t I post?” messaging for `insufficient_rank` and `capture_rate_limited`.
  - Node detail shows “You are rank X; this node requires Y.”

References:
- API endpoint: `apps/api/src/groundedart_api/api/routers/me.py`
- API schema: `apps/api/src/groundedart_api/api/schemas.py`
- Shared contract: `packages/domain/schemas/me_response.json`
- Web `me` client/types/copy: `apps/web/src/features/me/api.ts`, `apps/web/src/features/me/types.ts`, `apps/web/src/features/me/copy.ts`
- Web surfaces: `apps/web/src/routes/MapRoute.tsx`, `apps/web/src/features/captures/CaptureFlow.tsx`, `apps/web/src/routes/NodeDetailRoute.tsx`

## Shared rank event contracts (schemas)
- Rank event and list-response schemas exist in `packages/domain/schemas/`:
  - `rank_event.json`, `rank_event_type.json`, `rank_events_response.json`
- The API defines Pydantic models for `RankEvent`/`RankEventsResponse`, but there is currently no public router exposing a rank events endpoint.

References:
- Schemas: `packages/domain/schemas/rank_event.json`, `packages/domain/schemas/rank_event_type.json`, `packages/domain/schemas/rank_events_response.json`
- API models: `apps/api/src/groundedart_api/api/schemas.py`

## Backfill support
- A backfill script exists to populate `rank_events` for existing verified captures:
  - It derives `created_at` from the last transition-to-verified capture event when available, otherwise falls back to `captures.created_at`.
  - It is idempotent via the same unique constraint used by runtime writes.

References:
- Backfill: `apps/api/scripts/backfill_rank_events.py`

## Tests touching M4
- API:
  - Rank emission + projection: `apps/api/tests/test_rank_events.py`
  - Discovery gating + “locked nodes” behavior: `apps/api/tests/test_nodes.py`
  - Optional auth/anonymous gating behavior: `apps/api/tests/test_auth_gates.py`
- Web:
  - Map rank panel and related behavior: `apps/web/src/routes/MapRoute.test.tsx`
  - Capture flow rank-related messaging paths: `apps/web/src/features/captures/CaptureFlow.test.tsx`

## Areas to address / review
- **Rank materialization correctness**: rank is derived from `rank_events` but reads should use `curator_rank_cache` / `curator_rank_daily`. Verify cache updates on moderation transitions (verified↔hidden) and define a rebuild/backfill strategy.
- **Idempotency keys (next)**: start designing deterministic primary keys for rank events (hash of defining attributes) so future event types can be safely retried without relying on `(event_type, capture_id)`.
- **Check-in UX gaps**: the web check-in flow does not yet surface rank-related API failures (e.g. `insufficient_rank`, `checkin_challenge_rate_limited`, `capture_rate_limited`) even though the API can return them (rate-limit errors now include retry metadata).
- **Rank visibility planning**: define, explicitly, what each rank tier can see/do so we never rely on user-facing 404/403 for “locked content” (map population, node metadata, capture visibility, actions).
